<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Water Sort Solver</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; font-size: 12px; color: #333; margin-bottom: 4px; }
    input[type="number"] { width: 160px; padding: 6px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #bbb; background: #fafafa; cursor: pointer; }
    button:hover { background: #f2f2f2; }
    button:disabled { cursor: not-allowed; opacity: 0.55; }
    .colors { display: flex; gap: 10px; flex-wrap: wrap; }
    .colors label { display:flex; gap:8px; align-items:center; font-size: 13px; user-select:none; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.2); display:inline-block; }
    .bottles { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 12px; margin-top: 12px; }
    .bottle { border: 1px solid #ddd; border-radius: 12px; padding: 10px; }
    .bottle h3 { margin: 0 0 8px; font-size: 14px; display:flex; justify-content:space-between; }
    .layers { display: grid; grid-template-columns: 1fr; gap: 6px; }
    select { padding: 6px; border-radius: 8px; border: 1px solid #ccc; }
    .hint { font-size: 12px; color: #555; margin-top: 8px; }
    .output { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; background: #0b1020; color: #e6e6e6; padding: 12px; border-radius: 12px; overflow:auto; max-height: 55vh; }
    .warn { color: #b00020; font-size: 13px; margin-top: 8px; }
    .ok { color: #0a7a22; font-size: 13px; margin-top: 8px; }
    .small { font-size: 12px; color:#444; }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .divider { height:1px; background:#eee; margin: 10px 0; }
  </style>
</head>
<body>
  <h1>Water Sort Solver (manual input → step-by-step solution)</h1>

  <div class="row">
    <div class="card">
      <div class="row">
        <div>
          <label>Number of bottles (max 14)</label>
          <input id="numBottles" type="number" min="3" max="14" value="11">
        </div>
      </div>
      <div class="hint">
        Capacity is always <b>4</b>. Last <b>2 bottles</b> are forced empty (helpers). All other bottles must be full.
      </div>
      <div class="inline" style="margin-top:10px;">
        <button id="resetBtn">Reset</button>
      </div>
      <div id="buildMsg" class="small"></div>
    </div>

    <div class="card" style="flex:1; min-width: 320px;">
      <label>Select colors in this level</label>
      <div id="colorChecklist" class="colors"></div>

      <div class="hint" id="colorLimitHint"></div>

      <div class="divider"></div>

      <div class="inline">
        <button id="buildBtn">Build bottles UI</button>
      </div>
      <div class="hint">
        You can select at most <b>(bottles − 2)</b> colors. Each selected color must appear exactly <b>4</b> times.
      </div>
    </div>
  </div>

  <div id="bottleArea" class="bottles"></div>

  <div class="row" style="margin-top: 12px;">
    <div class="card" style="flex:1;">
      <div class="inline">
        <button id="solveBtn" disabled>Solve</button>
        <label class="inline" style="gap:6px; margin:0;">
          <input id="showStates" type="checkbox" checked>
          Show state after each move
        </label>
        <label class="inline" style="gap:6px; margin:0;">
          <input id="shortMoves" type="checkbox">
          Only moves (no poured amount)
        </label>
      </div>
      <div id="status" class="hint"></div>
      <div id="error" class="warn"></div>
      <div id="success" class="ok"></div>
    </div>
  </div>

  <div class="row" style="margin-top: 12px;">
    <div class="card" style="flex:1;">
      <label>Solution</label>
      <div id="output" class="output">Build bottles UI, enter colors, then press Solve.</div>
    </div>
  </div>

<script>
  const CAP = 4;

  const COLOR_PALETTE = {
    "Red": "#e53935",
    "Pink": "#ec407a",
    "Orange": "#fb8c00",
    "Yellow": "#fdd835",
    "Green": "#43a047",
    "Dark Green": "#1b5e20",
    "Light Green": "#9ccc65",
    "Blue": "#1e88e5",
    "Light Blue": "#81d4fa",
    "Purple": "#8e24aa",
    "Gray": "#9e9e9e",
    "Brown": "#6d4c41",
  };
  const DEFAULT_COLORS = Object.keys(COLOR_PALETTE);

  const el = (id) => document.getElementById(id);

  function selectedColors() {
    return Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]:checked"))
      .map(x => x.value);
  }

  function showError(msg) {
    el("error").textContent = msg;
    el("success").textContent = "";
  }

  function showSuccess(msg) {
    el("success").textContent = msg;
    el("error").textContent = "";
  }

  // ---------- Improvement #1: checkbox max = bottles-2 ----------
  function colorMaxAllowed() {
    const n = parseInt(el("numBottles").value, 10);
    return Math.max(1, Math.min(12, n - 2)); // max bottles=14 => max colors=12
  }

  function updateColorLimitUI() {
    const max = colorMaxAllowed();
    const chosen = selectedColors().length;
    el("colorLimitHint").textContent = `Selected ${chosen}/${max} colors.`;

    const checkboxes = Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]"));
    const lock = chosen >= max;
    for (const cb of checkboxes) {
      if (!cb.checked) cb.disabled = lock;
      else cb.disabled = false;
    }
  }

  function buildChecklist() {
    const box = el("colorChecklist");
    box.innerHTML = "";
    DEFAULT_COLORS.forEach((c) => {
      const lab = document.createElement("label");

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = c;
      cb.addEventListener("change", () => {
        const max = colorMaxAllowed();
        const chosen = selectedColors().length;
        if (chosen > max) cb.checked = false;

        updateColorLimitUI();
        updateAllDropdownOptions();
        updateSolveEnabled();
      });

      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = COLOR_PALETTE[c] || "#ccc";

      const name = document.createElement("span");
      name.textContent = c;

      lab.appendChild(cb);
      lab.appendChild(sw);
      lab.appendChild(name);
      box.appendChild(lab);
    });

    updateColorLimitUI();
  }

  // ---------- Reset ----------
  function resetAll() {
    el("numBottles").value = 11;
    el("showStates").checked = true;
    el("shortMoves").checked = false;

    el("colorChecklist").querySelectorAll("input[type=checkbox]").forEach(cb => {
      cb.checked = false;
      cb.disabled = false;
    });

    el("bottleArea").innerHTML = "";
    el("buildMsg").textContent = "";
    el("status").textContent = "";
    el("error").textContent = "";
    el("success").textContent = "";
    el("output").textContent = "Build bottles UI, enter colors, then press Solve.";
    el("solveBtn").disabled = true;

    updateColorLimitUI();
  }

  // ---------- Build bottles ----------
  function buildBottlesUI() {
    const n = parseInt(el("numBottles").value, 10);
    const colors = selectedColors();

    el("error").textContent = "";
    el("success").textContent = "";

    if (!Number.isFinite(n) || n < 3) return showError("Number of bottles must be >= 3.");
    if (n > 14) return showError("Max bottles is 14.");

    const maxColors = n - 2;
    if (colors.length === 0) return showError("Select at least 1 color.");
    if (colors.length > maxColors) return showError(`Too many colors selected. Max is ${maxColors}.`);

    const area = el("bottleArea");
    area.innerHTML = "";

    for (let i = 0; i < n; i++) {
      const isHelperEmpty = (i >= n - 2);

      const b = document.createElement("div");
      b.className = "bottle";
      b.dataset.index = String(i);

      const title = document.createElement("h3");
      title.innerHTML = `<span>Bottle ${i+1}</span><span class="small">${isHelperEmpty ? "EMPTY" : ""}</span>`;
      b.appendChild(title);

      const layers = document.createElement("div");
      layers.className = "layers";

      for (let row = 0; row < CAP; row++) {
        const sel = document.createElement("select");
        sel.dataset.layer = String(row);

        if (isHelperEmpty) {
          sel.disabled = true;
          sel.innerHTML = `<option value="" hidden></option>`;
        } else {
          sel.innerHTML = `<option value="" hidden></option>`;
          sel.addEventListener("change", () => {
            setSelectBackground(sel);
            updateAllDropdownOptions();
            updateSolveEnabled();
          });
        }
        layers.appendChild(sel);
      }

      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = isHelperEmpty
        ? "Helper bottle (forced empty)"
        : "Set colors TOP → BOTTOM (must fill all 4 layers). Dropdown shows remaining layers per color.";
      b.appendChild(layers);
      b.appendChild(hint);

      area.appendChild(b);
    }

    el("buildMsg").textContent = `Built ${n} bottles (capacity fixed to 4).`;
    el("status").textContent = "Fill the bottles. Solve unlocks when everything is valid.";
    el("output").textContent = "Ready.";

    updateAllDropdownOptions(true);
    updateSolveEnabled();
  }

  function getAllUserSelects() {
    return Array.from(el("bottleArea").querySelectorAll(".bottle select"))
      .filter(sel => !sel.disabled);
  }

  function computeUsedCounts() {
    const counts = new Map();
    DEFAULT_COLORS.forEach(c => counts.set(c, 0));
    for (const sel of getAllUserSelects()) {
      const v = sel.value;
      if (v) counts.set(v, (counts.get(v) || 0) + 1);
    }
    return counts;
  }

  function setSelectBackground(sel) {
    const v = sel.value;
    if (!v) {
      sel.style.backgroundColor = "";
      sel.style.color = "";
      return;
    }
    const bg = COLOR_PALETTE[v] || "";
    sel.style.backgroundColor = bg;
    sel.style.color = (v === "Yellow" || v === "Light Blue" || v === "Light Green") ? "#111" : "#fff";
  }

  function updateAllDropdownOptions(initialPopulate = false) {
    const area = el("bottleArea");
    if (!area || area.children.length === 0) return;

    const colors = selectedColors();
    if (colors.length === 0) return;

    const used = computeUsedCounts();
    const selects = getAllUserSelects();

    for (const sel of selects) {
      const current = sel.value || "";

      const opts = [];
      opts.push({ value: "", label: "", hidden: true });

      for (const c of colors) {
        const usedTotal = used.get(c) || 0;
        const effectiveUsed = usedTotal - (current === c ? 1 : 0);
        const remainingNow = CAP - effectiveUsed;

        if (remainingNow <= 0 && current !== c) continue;

        const label = (current === c) ? `${c}` : `${c} (${Math.max(0, remainingNow)} left)`;
        opts.push({ value: c, label, hidden: false });
      }

      sel.innerHTML = "";
      for (const o of opts) {
        const opt = document.createElement("option");
        opt.value = o.value;
        opt.textContent = o.label;
        if (o.hidden) opt.hidden = true;

        if (o.value && COLOR_PALETTE[o.value]) {
          opt.style.backgroundColor = COLOR_PALETTE[o.value];
          opt.style.color = (o.value === "Yellow" || o.value === "Light Blue" || o.value === "Light Green") ? "#111" : "#fff";
        }
        sel.appendChild(opt);
      }

      if (current) {
        const found = Array.from(sel.options).some(o => o.value === current);
        sel.value = found ? current : "";
      } else if (initialPopulate) {
        sel.value = "";
      }

      setSelectBackground(sel);
    }

    const n = parseInt(el("numBottles").value, 10);
    const totalSlots = (n - 2) * CAP;
    const filled = selects.filter(s => s.value).length;
    el("status").textContent = `Filled ${filled}/${totalSlots} layers.`;
  }

  // ---------- Solve enable logic ----------
  function allPlacedAndValid() {
    const area = el("bottleArea");
    if (!area || area.children.length === 0) return { ok:false, reason:"Build bottles UI first." };

    const n = parseInt(el("numBottles").value, 10);
    const colors = selectedColors();
    if (colors.length === 0) return { ok:false, reason:"Select colors first." };

    const max = n - 2;
    if (colors.length > max) return { ok:false, reason:`Too many colors selected.` };

    const selects = getAllUserSelects();
    const totalSlots = (n - 2) * CAP;

    const filled = selects.filter(s => s.value).length;
    if (filled !== totalSlots) return { ok:false, reason:"Fill all layers first." };

    const used = computeUsedCounts();
    for (const c of colors) {
      if ((used.get(c) || 0) !== CAP) return { ok:false, reason:`"${c}" is not exactly 4.` };
    }
    return { ok:true, reason:"Ready." };
  }

  function updateSolveEnabled() {
    const verdict = allPlacedAndValid();
    el("solveBtn").disabled = !verdict.ok;
  }

  // ---------- Core puzzle rules ----------
  function isSolved(state) {
    for (const b of state) {
      if (b.length === 0) continue;
      if (b.length !== CAP) return false;
      const c0 = b[0];
      for (let i = 1; i < b.length; i++) if (b[i] !== c0) return false;
    }
    return true;
  }

  function topRun(b) {
    if (b.length === 0) return null;
    const tc = b[b.length - 1];
    let run = 1;
    for (let i = b.length - 2; i >= 0; i--) {
      if (b[i] === tc) run++;
      else break;
    }
    return { color: tc, run };
  }

  function canPour(src, dst) {
    if (src.length === 0) return false;
    if (dst.length >= CAP) return false;
    if (dst.length === 0) return true;
    return dst[dst.length - 1] === src[src.length - 1];
  }

  function doPour(src, dst) {
    const tr = topRun(src);
    const space = CAP - dst.length;
    const amt = Math.min(tr.run, space);
    const newSrc = src.slice(0, src.length - amt);
    const newDst = dst.concat(Array(amt).fill(tr.color));
    return { newSrc, newDst, amt, color: tr.color };
  }

  function encodeState(state) {
    return state.map(b => b.join(",")).join("|");
  }

  function cloneState(state) {
    return state.map(b => b.slice());
  }

  function usefulMovePrune(src, dst) {
    // don't pour from a uniform full bottle into empty
    if (dst.length === 0 && src.length === CAP) {
      const c0 = src[0];
      let allSame = true;
      for (let i = 1; i < src.length; i++) if (src[i] !== c0) { allSame = false; break; }
      if (allSame) return false;
    }
    return true;
  }

  // ---------- A* Implementation ----------
  class MinHeap {
    constructor() { this.a = []; }
    size() { return this.a.length; }
    push(x) {
      this.a.push(x);
      this._siftUp(this.a.length - 1);
    }
    pop() {
      if (this.a.length === 0) return null;
      const root = this.a[0];
      const last = this.a.pop();
      if (this.a.length > 0) {
        this.a[0] = last;
        this._siftDown(0);
      }
      return root;
    }
    _siftUp(i) {
      while (i > 0) {
        const p = (i - 1) >> 1;
        if (this.a[p].f <= this.a[i].f) break;
        [this.a[p], this.a[i]] = [this.a[i], this.a[p]];
        i = p;
      }
    }
    _siftDown(i) {
      const n = this.a.length;
      while (true) {
        let l = i * 2 + 1;
        let r = l + 1;
        let m = i;
        if (l < n && this.a[l].f < this.a[m].f) m = l;
        if (r < n && this.a[r].f < this.a[m].f) m = r;
        if (m === i) break;
        [this.a[m], this.a[i]] = [this.a[i], this.a[m]];
        i = m;
      }
    }
  }

  // Heuristic: counts "disorder" by segments; fast & effective.
  // (Not guaranteed admissible => solution may not be the shortest, but it’s usually much faster than BFS.)
  function heuristic(state) {
    let h = 0;
    for (const b of state) {
      if (b.length === 0) continue;

      // if already solved bottle => 0
      if (b.length === CAP) {
        let uniform = true;
        for (let i = 1; i < CAP; i++) if (b[i] !== b[0]) { uniform = false; break; }
        if (uniform) continue;
      }

      // Count color segments bottom->top
      let seg = 1;
      for (let i = 1; i < b.length; i++) if (b[i] !== b[i-1]) seg++;

      // More segments => more mixing => more work
      h += (seg - 1);

      // Small extra penalty for partially-filled mixed bottles
      if (b.length < CAP) h += 1;
    }
    return h;
  }

  function aStarSolve(startState, maxExpansions = 1200000) {
    const startKey = encodeState(startState);

    // best known g (moves) for each state
    const bestG = new Map();
    bestG.set(startKey, 0);

    // parent pointers for reconstruction
    const parent = new Map();
    parent.set(startKey, null);

    const open = new MinHeap();
    open.push({ key: startKey, state: startState, g: 0, f: heuristic(startState) });

    let expanded = 0;

    while (open.size() > 0) {
      const node = open.pop();
      if (!node) break;

      // Skip outdated heap entries
      const knownG = bestG.get(node.key);
      if (knownG !== node.g) continue;

      expanded++;
      if (expanded % 5000 === 0) {
        el("status").textContent = `Searching (A*)... expanded ${expanded.toLocaleString()} states`;
      }
      if (expanded > maxExpansions) {
        return { ok:false, reason:`State limit reached (${maxExpansions.toLocaleString()}).`, explored: expanded };
      }

      if (isSolved(node.state)) {
        // reconstruct moves
        const moves = [];
        let k = node.key;
        while (parent.get(k) !== null) {
          const rec = parent.get(k);
          moves.push(rec.move);
          k = rec.prevKey;
        }
        moves.reverse();
        return { ok:true, moves, explored: expanded };
      }

      const n = node.state.length;
      const lastRec = parent.get(node.key);
      const lastMove = lastRec ? lastRec.move : null;

      for (let i = 0; i < n; i++) {
        const src = node.state[i];
        if (src.length === 0) continue;

        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          // avoid immediate undo
          if (lastMove && lastMove.from === j && lastMove.to === i) continue;

          const dst = node.state[j];
          if (!canPour(src, dst)) continue;
          if (!usefulMovePrune(src, dst)) continue;

          const next = cloneState(node.state);
          const res = doPour(next[i], next[j]);
          next[i] = res.newSrc;
          next[j] = res.newDst;

          const key = encodeState(next);
          const g2 = node.g + 1;

          const prevBest = bestG.get(key);
          if (prevBest !== undefined && prevBest <= g2) continue;

          bestG.set(key, g2);
          parent.set(key, { prevKey: node.key, move: { from:i, to:j, amt:res.amt, color:res.color } });

          const f2 = g2 + heuristic(next);
          open.push({ key, state: next, g: g2, f: f2 });
        }
      }
    }

    return { ok:false, reason:"No solution found (input may be invalid).", explored: expanded };
  }

  // ---------- Read / Validate / Format ----------
  function readStateFromUI() {
    const n = parseInt(el("numBottles").value, 10);
    const bottles = [];

    for (let i = 0; i < n; i++) {
      const b = el("bottleArea").querySelector(`.bottle[data-index="${i}"]`);
      const selects = Array.from(b.querySelectorAll("select"));
      const topToBottom = selects.map(s => s.value).filter(v => v !== "");
      const bottomToTop = topToBottom.slice().reverse();
      bottles.push(bottomToTop);
    }
    return bottles;
  }

  function validateInput(bottles) {
    const n = bottles.length;
    const colors = selectedColors();

    if (colors.length === 0) return "Select colors first.";
    if (bottles[n-1].length !== 0 || bottles[n-2].length !== 0) {
      return "Last 2 bottles must be empty (helpers).";
    }
    for (let i = 0; i < n - 2; i++) {
      if (bottles[i].length !== CAP) return `Bottle ${i+1} must have exactly ${CAP} layers (full).`;
    }
    const counts = new Map();
    for (const c of colors) counts.set(c, 0);
    for (const b of bottles) for (const c of b) {
      if (!counts.has(c)) return `Color "${c}" is used but not selected in the checklist.`;
      counts.set(c, counts.get(c) + 1);
    }
    for (const c of colors) {
      const k = counts.get(c) || 0;
      if (k !== CAP) return `Color "${c}" appears ${k} times, but must appear exactly ${CAP} times.`;
    }
    return null;
  }

  function formatState(state) {
    let out = "";
    for (let i = 0; i < state.length; i++) {
      const b = state[i];
      const topToBottom = b.slice().reverse();
      const padded = topToBottom.concat(Array(CAP - topToBottom.length).fill("·"));
      out += `${String(i+1).padStart(2," ")}: ${padded.join("  ")}\n`;
    }
    return out;
  }

  function applyMove(state, move) {
    const next = cloneState(state);
    const res = doPour(next[move.from], next[move.to]);
    next[move.from] = res.newSrc;
    next[move.to] = res.newDst;
    return next;
  }

  // ---------- Wiring ----------
  buildChecklist();

  el("resetBtn").addEventListener("click", resetAll);

  el("numBottles").addEventListener("change", () => {
    let v = parseInt(el("numBottles").value, 10);
    if (v > 14) v = 14;
    if (v < 3) v = 3;
    el("numBottles").value = v;

    // if too many colors already checked, auto-uncheck extras (keep earliest checked)
    const max = colorMaxAllowed();
    const checked = Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]:checked"));
    if (checked.length > max) {
      for (let k = max; k < checked.length; k++) checked[k].checked = false;
    }
    updateColorLimitUI();
    updateAllDropdownOptions();
    updateSolveEnabled();
  });

  el("buildBtn").addEventListener("click", () => {
    updateColorLimitUI();
    buildBottlesUI();
  });

  el("solveBtn").addEventListener("click", () => {
    el("error").textContent = "";
    el("success").textContent = "";
    try {
      const bottles = readStateFromUI();
      const err = validateInput(bottles);
      if (err) return showError(err);

      el("output").textContent = "Solving with A*...\n";
      el("status").textContent = "Starting search (A*)...";
      const t0 = performance.now();

      // You can raise/lower this if needed:
      const result = aStarSolve(bottles, 1200000);

      const t1 = performance.now();

      if (!result.ok) {
        showError(`Failed: ${result.reason}`);
        el("output").textContent =
          `Failed: ${result.reason}\nExpanded: ${result.explored.toLocaleString()} states\nTime: ${(t1-t0).toFixed(0)} ms`;
        return;
      }

      showSuccess(`Solved! Moves: ${result.moves.length}. Expanded: ${result.explored.toLocaleString()} states. Time: ${(t1-t0).toFixed(0)} ms`);
      el("status").textContent = "Done.";

      const showStates = el("showStates").checked;
      const shortMoves = el("shortMoves").checked;

      let text = "";
      text += `Initial state (top→bottom):\n${formatState(bottles)}\n`;
      let cur = bottles;

      result.moves.forEach((m, idx) => {
        const line = shortMoves
          ? `${idx+1}. ${m.from+1} → ${m.to+1}`
          : `${idx+1}. ${m.from+1} → ${m.to+1}  (poured ${m.amt} × ${m.color})`;
        text += line + "\n";
        cur = applyMove(cur, m);
        if (showStates) text += formatState(cur) + "\n";
      });

      el("output").textContent = text;
    } catch (e) {
      showError(String(e?.message || e));
    }
  });
</script>
</body>
</html>
