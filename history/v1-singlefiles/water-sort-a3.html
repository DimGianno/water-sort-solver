<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Water Sort Solver</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; font-size: 12px; color: #333; margin-bottom: 4px; }
    input[type="number"] { width: 160px; padding: 6px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #bbb; background: #fafafa; cursor: pointer; }
    button:hover { background: #f2f2f2; }
    button:disabled { cursor: not-allowed; opacity: 0.55; }
    .colors { display: flex; gap: 10px; flex-wrap: wrap; }
    .colors label { display:flex; gap:8px; align-items:center; font-size: 13px; user-select:none; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.2); display:inline-block; }
    .bottles { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 12px; margin-top: 12px; }
    .bottle { border: 1px solid #ddd; border-radius: 12px; padding: 10px; }
    .bottle h3 { margin: 0 0 8px; font-size: 14px; display:flex; justify-content:space-between; }
    .layers { display: grid; grid-template-columns: 1fr; gap: 6px; }
    select { padding: 6px; border-radius: 8px; border: 1px solid #ccc; }
    .hint { font-size: 12px; color: #555; margin-top: 8px; }
    .output { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; background: #0b1020; color: #e6e6e6; padding: 12px; border-radius: 12px; overflow:auto; max-height: 55vh; }
    .warn { color: #b00020; font-size: 13px; margin-top: 8px; }
    .ok { color: #0a7a22; font-size: 13px; margin-top: 8px; }
    .small { font-size: 12px; color:#444; }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .divider { height:1px; background:#eee; margin: 10px 0; }
  </style>
</head>
<body>
  <h1>Water Sort Solver (manual input → step-by-step solution)</h1>

  <div class="row">
    <div class="card">
      <div class="row">
        <div>
          <label>Number of bottles (max 14)</label>
          <input id="numBottles" type="number" min="3" max="14" value="11">
        </div>
      </div>
      <div class="hint">
        Capacity is always <b>4</b>. Last <b>2 bottles</b> are forced empty (helpers). All other bottles must be full.
      </div>
      <div class="inline" style="margin-top:10px;">
        <button id="resetBtn">Reset</button>
      </div>
      <div id="buildMsg" class="small"></div>
    </div>

    <div class="card" style="flex:1; min-width: 320px;">
      <label>Select colors in this level</label>
      <div id="colorChecklist" class="colors"></div>

      <div class="hint" id="colorLimitHint"></div>

      <div class="divider"></div>

      <div class="inline">
        <button id="buildBtn">Build bottles UI</button>
      </div>
      <div class="hint">
        You can select at most <b>(bottles − 2)</b> colors. Each selected color must appear exactly <b>4</b> times.
      </div>
    </div>
  </div>

  <div id="bottleArea" class="bottles"></div>

  <div class="row" style="margin-top: 12px;">
    <div class="card" style="flex:1;">
      <div class="inline">
        <button id="solveBtn" disabled>Solve</button>

        <div class="inline" style="gap:6px;">
          <label style="margin:0;">Mode</label>
          <select id="modeSel">
            <option value="fast" selected>Fast</option>
            <option value="optimal">Optimal-ish</option>
          </select>
        </div>

        <label class="inline" style="gap:6px; margin:0;">
          <input id="showStates" type="checkbox" checked>
          Show state after each move
        </label>
        <label class="inline" style="gap:6px; margin:0;">
          <input id="shortMoves" type="checkbox">
          Only moves (no poured amount)
        </label>
      </div>
      <div id="status" class="hint"></div>
      <div id="error" class="warn"></div>
      <div id="success" class="ok"></div>
    </div>
  </div>

  <div class="row" style="margin-top: 12px;">
    <div class="card" style="flex:1;">
      <label>Solution</label>
      <div id="output" class="output">Build bottles UI, enter colors, then press Solve.</div>
    </div>
  </div>

<script>
  const CAP = 4;

  const COLOR_PALETTE = {
    "Red": "#e53935",
    "Pink": "#ec407a",
    "Orange": "#fb8c00",
    "Yellow": "#fdd835",
    "Green": "#43a047",
    "Dark Green": "#1b5e20",
    "Light Green": "#9ccc65",
    "Blue": "#1e88e5",
    "Light Blue": "#81d4fa",
    "Purple": "#8e24aa",
    "Gray": "#9e9e9e",
    "Brown": "#6d4c41",
  };
  const DEFAULT_COLORS = Object.keys(COLOR_PALETTE);
  const el = (id) => document.getElementById(id);

  function selectedColors() {
    return Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]:checked"))
      .map(x => x.value);
  }
  function showError(msg) { el("error").textContent = msg; el("success").textContent = ""; }
  function showSuccess(msg) { el("success").textContent = msg; el("error").textContent = ""; }

  // ---------- Color selection limit ----------
  function colorMaxAllowed() {
    const n = parseInt(el("numBottles").value, 10);
    return Math.max(1, Math.min(12, n - 2));
  }
  function updateColorLimitUI() {
    const max = colorMaxAllowed();
    const chosen = selectedColors().length;
    el("colorLimitHint").textContent = `Selected ${chosen}/${max} colors.`;
    const checkboxes = Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]"));
    const lock = chosen >= max;
    for (const cb of checkboxes) cb.disabled = (!cb.checked && lock);
  }

  function buildChecklist() {
    const box = el("colorChecklist");
    box.innerHTML = "";
    DEFAULT_COLORS.forEach((c) => {
      const lab = document.createElement("label");
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = c;
      cb.addEventListener("change", () => {
        const max = colorMaxAllowed();
        const chosen = selectedColors().length;
        if (chosen > max) cb.checked = false;
        updateColorLimitUI();
        updateAllDropdownOptions();
        updateSolveEnabled();
      });

      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = COLOR_PALETTE[c] || "#ccc";

      const name = document.createElement("span");
      name.textContent = c;

      lab.appendChild(cb);
      lab.appendChild(sw);
      lab.appendChild(name);
      box.appendChild(lab);
    });
    updateColorLimitUI();
  }

  // ---------- Reset ----------
  function resetAll() {
    el("numBottles").value = 11;
    el("showStates").checked = true;
    el("shortMoves").checked = false;
    el("modeSel").value = "fast";

    el("colorChecklist").querySelectorAll("input[type=checkbox]").forEach(cb => {
      cb.checked = false; cb.disabled = false;
    });

    el("bottleArea").innerHTML = "";
    el("buildMsg").textContent = "";
    el("status").textContent = "";
    el("error").textContent = "";
    el("success").textContent = "";
    el("output").textContent = "Build bottles UI, enter colors, then press Solve.";
    el("solveBtn").disabled = true;

    updateColorLimitUI();
  }

  // ---------- Build bottles UI ----------
  function buildBottlesUI() {
    const n = parseInt(el("numBottles").value, 10);
    const colors = selectedColors();

    el("error").textContent = "";
    el("success").textContent = "";

    if (!Number.isFinite(n) || n < 3) return showError("Number of bottles must be >= 3.");
    if (n > 14) return showError("Max bottles is 14.");

    const maxColors = n - 2;
    if (colors.length === 0) return showError("Select at least 1 color.");
    if (colors.length > maxColors) return showError(`Too many colors selected. Max is ${maxColors}.`);

    const area = el("bottleArea");
    area.innerHTML = "";

    for (let i = 0; i < n; i++) {
      const isHelperEmpty = (i >= n - 2);

      const b = document.createElement("div");
      b.className = "bottle";
      b.dataset.index = String(i);

      const title = document.createElement("h3");
      title.innerHTML = `<span>Bottle ${i+1}</span><span class="small">${isHelperEmpty ? "EMPTY" : ""}</span>`;
      b.appendChild(title);

      const layers = document.createElement("div");
      layers.className = "layers";

      for (let row = 0; row < CAP; row++) {
        const sel = document.createElement("select");
        sel.dataset.layer = String(row);

        if (isHelperEmpty) {
          sel.disabled = true;
          sel.innerHTML = `<option value="" hidden></option>`;
        } else {
          sel.innerHTML = `<option value="" hidden></option>`;
          sel.addEventListener("change", () => {
            setSelectBackground(sel);
            updateAllDropdownOptions();
            updateSolveEnabled();
          });
        }
        layers.appendChild(sel);
      }

      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = isHelperEmpty
        ? "Helper bottle (forced empty)"
        : "Set colors TOP → BOTTOM (must fill all 4 layers). Dropdown shows remaining layers per color.";
      b.appendChild(layers);
      b.appendChild(hint);

      area.appendChild(b);
    }

    el("buildMsg").textContent = `Built ${n} bottles (capacity fixed to 4).`;
    el("status").textContent = "Fill the bottles. Solve unlocks when everything is valid.";
    el("output").textContent = "Ready.";

    updateAllDropdownOptions(true);
    updateSolveEnabled();
  }

  function getAllUserSelects() {
    return Array.from(el("bottleArea").querySelectorAll(".bottle select"))
      .filter(sel => !sel.disabled);
  }

  function computeUsedCounts() {
    const counts = new Map();
    DEFAULT_COLORS.forEach(c => counts.set(c, 0));
    for (const sel of getAllUserSelects()) {
      const v = sel.value;
      if (v) counts.set(v, (counts.get(v) || 0) + 1);
    }
    return counts;
  }

  function setSelectBackground(sel) {
    const v = sel.value;
    if (!v) { sel.style.backgroundColor = ""; sel.style.color = ""; return; }
    const bg = COLOR_PALETTE[v] || "";
    sel.style.backgroundColor = bg;
    sel.style.color = (v === "Yellow" || v === "Light Blue" || v === "Light Green") ? "#111" : "#fff";
  }

  function updateAllDropdownOptions(initialPopulate = false) {
    const area = el("bottleArea");
    if (!area || area.children.length === 0) return;

    const colors = selectedColors();
    if (colors.length === 0) return;

    const used = computeUsedCounts();
    const selects = getAllUserSelects();

    for (const sel of selects) {
      const current = sel.value || "";
      const opts = [];
      opts.push({ value: "", label: "", hidden: true });

      for (const c of colors) {
        const usedTotal = used.get(c) || 0;
        const effectiveUsed = usedTotal - (current === c ? 1 : 0);
        const remainingNow = CAP - effectiveUsed;

        if (remainingNow <= 0 && current !== c) continue;

        const label = (current === c) ? `${c}` : `${c} (${Math.max(0, remainingNow)} left)`;
        opts.push({ value: c, label, hidden: false });
      }

      sel.innerHTML = "";
      for (const o of opts) {
        const opt = document.createElement("option");
        opt.value = o.value;
        opt.textContent = o.label;
        if (o.hidden) opt.hidden = true;

        if (o.value && COLOR_PALETTE[o.value]) {
          opt.style.backgroundColor = COLOR_PALETTE[o.value];
          opt.style.color = (o.value === "Yellow" || o.value === "Light Blue" || o.value === "Light Green") ? "#111" : "#fff";
        }
        sel.appendChild(opt);
      }

      if (current) {
        const found = Array.from(sel.options).some(o => o.value === current);
        sel.value = found ? current : "";
      } else if (initialPopulate) {
        sel.value = "";
      }
      setSelectBackground(sel);
    }

    const n = parseInt(el("numBottles").value, 10);
    const totalSlots = (n - 2) * CAP;
    const filled = selects.filter(s => s.value).length;
    el("status").textContent = `Filled ${filled}/${totalSlots} layers.`;
  }

  // ---------- Solve enable logic ----------
  function allPlacedAndValid() {
    const area = el("bottleArea");
    if (!area || area.children.length === 0) return { ok:false };

    const n = parseInt(el("numBottles").value, 10);
    const colors = selectedColors();
    if (colors.length === 0) return { ok:false };

    const max = n - 2;
    if (colors.length > max) return { ok:false };

    const selects = getAllUserSelects();
    const totalSlots = (n - 2) * CAP;
    const filled = selects.filter(s => s.value).length;
    if (filled !== totalSlots) return { ok:false };

    const used = computeUsedCounts();
    for (const c of colors) if ((used.get(c) || 0) !== CAP) return { ok:false };

    return { ok:true };
  }
  function updateSolveEnabled() { el("solveBtn").disabled = !allPlacedAndValid().ok; }

  // ---------- Core puzzle rules ----------
  function isSolved(state) {
    for (const b of state) {
      if (b.length === 0) continue;
      if (b.length !== CAP) return false;
      const c0 = b[0];
      for (let i = 1; i < b.length; i++) if (b[i] !== c0) return false;
    }
    return true;
  }
  function isUniform(b) {
    if (b.length === 0) return true;
    for (let i = 1; i < b.length; i++) if (b[i] !== b[0]) return false;
    return true;
  }
  function topRun(b) {
    if (b.length === 0) return null;
    const tc = b[b.length - 1];
    let run = 1;
    for (let i = b.length - 2; i >= 0; i--) {
      if (b[i] === tc) run++;
      else break;
    }
    return { color: tc, run };
  }
  function canPour(src, dst) {
    if (src.length === 0) return false;
    if (dst.length >= CAP) return false;
    if (dst.length === 0) return true;
    return dst[dst.length - 1] === src[src.length - 1];
  }
  function doPour(src, dst) {
    const tr = topRun(src);
    const space = CAP - dst.length;
    const amt = Math.min(tr.run, space);
    const newSrc = src.slice(0, src.length - amt);
    const newDst = dst.concat(Array(amt).fill(tr.color));
    return { newSrc, newDst, amt, color: tr.color };
  }
  function cloneState(state) { return state.map(b => b.slice()); }

  // ---------- Canonicalization ----------
  function bottleKey(b) { return b.join(","); } // bottom->top
  function canonicalKey(state) { return state.map(bottleKey).sort().join("|"); }

  // ---------- Safe pruning only ----------
  function usefulMovePrune(src, dst) {
    // provably safe: don't pour from a full uniform bottle into empty
    if (dst.length === 0 && src.length === CAP && isUniform(src)) return false;
    return true;
  }

  // ---------- A* ----------
  class MinHeap {
    constructor() { this.a = []; }
    size() { return this.a.length; }
    push(x) { this.a.push(x); this._up(this.a.length - 1); }
    pop() {
      if (this.a.length === 0) return null;
      const root = this.a[0];
      const last = this.a.pop();
      if (this.a.length) { this.a[0] = last; this._down(0); }
      return root;
    }
    _up(i) {
      while (i > 0) {
        const p = (i - 1) >> 1;
        if (this.a[p].f <= this.a[i].f) break;
        [this.a[p], this.a[i]] = [this.a[i], this.a[p]];
        i = p;
      }
    }
    _down(i) {
      const n = this.a.length;
      while (true) {
        let l = i * 2 + 1, r = l + 1, m = i;
        if (l < n && this.a[l].f < this.a[m].f) m = l;
        if (r < n && this.a[r].f < this.a[m].f) m = r;
        if (m === i) break;
        [this.a[m], this.a[i]] = [this.a[i], this.a[m]];
        i = m;
      }
    }
  }

  // Better heuristic (still not guaranteed admissible).
  function heuristic(state, mode) {
    let h = 0;

    // spread penalty
    const present = new Map();
    for (const b of state) {
      const seen = new Set(b);
      for (const c of seen) present.set(c, (present.get(c) || 0) + 1);
    }

    for (const b of state) {
      if (b.length === 0) continue;
      if (b.length === CAP && isUniform(b)) continue;

      // segments bottom->top
      let seg = 1;
      for (let i = 1; i < b.length; i++) if (b[i] !== b[i-1]) seg++;
      h += (seg - 1) * 2;

      // partial mixed bottle penalty
      if (b.length < CAP) h += 1;

      // reward bigger top runs
      const tr = topRun(b);
      if (tr) {
        if (tr.run === 3) h -= 2;
        else if (tr.run === 2) h -= 1;
      }
    }

    for (const [,k] of present) if (k > 1) h += (k - 1);

    // weights: Fast is more greedy; Optimal-ish less greedy
    const w = (mode === "fast") ? 1.35 : 1.0;
    return Math.max(0, Math.floor(h * w));
  }

  // Move scoring for ordering (NO pruning!). Higher score -> expand first.
  function scoreMove(state, mv, mode) {
    const src = state[mv.from];
    const dst = state[mv.to];

    let s = 0;

    // merging onto same color is good
    if (dst.length > 0 && dst[dst.length - 1] === src[src.length - 1]) s += 40;

    // pouring more is usually better (reduces branching)
    s += mv.amt * 6;

    // completing a bottle is very good
    const dstLenAfter = dst.length + mv.amt;
    if (dstLenAfter === CAP) s += 30;

    // revealing a different top in source is good (unblocks)
    const tr = topRun(src);
    if (tr && mv.amt >= tr.run) s += 18;

    // in optimal-ish, slightly prefer “clean merges” more than greedy fill empties
    if (mode === "optimal") {
      if (dst.length === 0) s -= 4; // tiny preference away from empty unless needed
    } else {
      // fast: don't penalize empties much; ordering will still prioritize merges
      if (dst.length === 0) s -= 1;
    }

    return s;
  }

  function generateMoves(state, mode, lastMove) {
    const n = state.length;
    const moves = [];

    // symmetry reduction for empty destination (safe):
    const emptyIndex = state.findIndex(b => b.length === 0);

    // symmetry reduction for identical destinations (safe):
    const dstSigSeen = new Set(); // dstKey|srcTop

    for (let i = 0; i < n; i++) {
      const src = state[i];
      if (src.length === 0) continue;

      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        if (lastMove && lastMove.from === j && lastMove.to === i) continue;

        const dst = state[j];

        // only consider one empty destination (empties are interchangeable)
        if (dst.length === 0 && emptyIndex !== -1 && j !== emptyIndex) continue;

        if (!canPour(src, dst)) continue;
        if (!usefulMovePrune(src, dst)) continue;

        const srcTop = src[src.length - 1];
        const sig = bottleKey(dst) + "|" + srcTop;
        if (dstSigSeen.has(sig)) continue;
        dstSigSeen.add(sig);

        const res = doPour(src, dst);
        moves.push({ from: i, to: j, amt: res.amt, color: res.color });
      }
    }

    // move ordering (key fix): try promising moves first
    moves.sort((a,b) => scoreMove(state, b, mode) - scoreMove(state, a, mode));
    return moves;
  }

  function applyMove(state, mv) {
    const next = cloneState(state);
    const res = doPour(next[mv.from], next[mv.to]);
    next[mv.from] = res.newSrc;
    next[mv.to] = res.newDst;
    return next;
  }

  function aStarSolve(startState, mode) {
    const maxExp = (mode === "fast") ? 1600000 : 2400000;

    const startKey = canonicalKey(startState);

    const bestG = new Map();
    bestG.set(startKey, 0);

    const parent = new Map();
    parent.set(startKey, null);

    const open = new MinHeap();
    open.push({ key: startKey, state: startState, g: 0, f: heuristic(startState, mode) });

    let expanded = 0;

    while (open.size() > 0) {
      const node = open.pop();
      if (!node) break;

      const knownG = bestG.get(node.key);
      if (knownG !== node.g) continue;

      expanded++;
      if (expanded % 5000 === 0) {
        el("status").textContent = `Searching (A* ${mode})... expanded ${expanded.toLocaleString()} states`;
      }
      if (expanded > maxExp) {
        return { ok:false, reason:`State limit reached (${maxExp.toLocaleString()}).`, explored: expanded };
      }

      if (isSolved(node.state)) {
        const moves = [];
        let k = node.key;
        while (parent.get(k) !== null) {
          const rec = parent.get(k);
          moves.push(rec.move);
          k = rec.prevKey;
        }
        moves.reverse();
        return { ok:true, moves, explored: expanded };
      }

      const lastRec = parent.get(node.key);
      const lastMove = lastRec ? lastRec.move : null;

      const moves = generateMoves(node.state, mode, lastMove);

      for (const mv of moves) {
        const next = applyMove(node.state, mv);
        const key2 = canonicalKey(next);
        const g2 = node.g + 1;

        const prev = bestG.get(key2);
        if (prev !== undefined && prev <= g2) continue;

        bestG.set(key2, g2);
        parent.set(key2, { prevKey: node.key, move: mv });

        const f2 = g2 + heuristic(next, mode);
        open.push({ key: key2, state: next, g: g2, f: f2 });
      }
    }

    return { ok:false, reason:"No solution found (input may be invalid).", explored: expanded };
  }

  // ---------- Read / Validate / Format ----------
  function readStateFromUI() {
    const n = parseInt(el("numBottles").value, 10);
    const bottles = [];
    for (let i = 0; i < n; i++) {
      const b = el("bottleArea").querySelector(`.bottle[data-index="${i}"]`);
      const selects = Array.from(b.querySelectorAll("select"));
      const topToBottom = selects.map(s => s.value).filter(v => v !== "");
      const bottomToTop = topToBottom.slice().reverse();
      bottles.push(bottomToTop);
    }
    return bottles;
  }

  function validateInput(bottles) {
    const n = bottles.length;
    const colors = selectedColors();

    if (colors.length === 0) return "Select colors first.";
    if (bottles[n-1].length !== 0 || bottles[n-2].length !== 0) return "Last 2 bottles must be empty (helpers).";
    for (let i = 0; i < n - 2; i++) if (bottles[i].length !== CAP) return `Bottle ${i+1} must have exactly ${CAP} layers (full).`;

    const counts = new Map();
    for (const c of colors) counts.set(c, 0);
    for (const b of bottles) for (const c of b) {
      if (!counts.has(c)) return `Color "${c}" is used but not selected in the checklist.`;
      counts.set(c, counts.get(c) + 1);
    }
    for (const c of colors) if ((counts.get(c) || 0) !== CAP) return `Color "${c}" appears ${counts.get(c) || 0} times, but must appear exactly ${CAP} times.`;

    return null;
  }

  function formatState(state) {
    let out = "";
    for (let i = 0; i < state.length; i++) {
      const b = state[i];
      const topToBottom = b.slice().reverse();
      const padded = topToBottom.concat(Array(CAP - topToBottom.length).fill("·"));
      out += `${String(i+1).padStart(2," ")}: ${padded.join("  ")}\n`;
    }
    return out;
  }

  function applyMoveForPrint(state, mv) {
    const next = cloneState(state);
    const res = doPour(next[mv.from], next[mv.to]);
    next[mv.from] = res.newSrc;
    next[mv.to] = res.newDst;
    return next;
  }

  // ---------- Wiring ----------
  buildChecklist();

  el("resetBtn").addEventListener("click", resetAll);

  el("numBottles").addEventListener("change", () => {
    let v = parseInt(el("numBottles").value, 10);
    if (v > 14) v = 14;
    if (v < 3) v = 3;
    el("numBottles").value = v;

    const max = colorMaxAllowed();
    const checked = Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]:checked"));
    if (checked.length > max) for (let k = max; k < checked.length; k++) checked[k].checked = false;

    updateColorLimitUI();
    updateAllDropdownOptions();
    updateSolveEnabled();
  });

  el("buildBtn").addEventListener("click", () => { updateColorLimitUI(); buildBottlesUI(); });

  el("solveBtn").addEventListener("click", () => {
    el("error").textContent = "";
    el("success").textContent = "";
    try {
      const bottles = readStateFromUI();
      const err = validateInput(bottles);
      if (err) return showError(err);

      const mode = el("modeSel").value === "optimal" ? "optimal" : "fast";

      el("output").textContent = `Solving with A* (${mode}) + canonicalization + move ordering...\n`;
      el("status").textContent = "Starting search...";
      const t0 = performance.now();

      const result = aStarSolve(bottles, mode);

      const t1 = performance.now();

      if (!result.ok) {
        showError(`Failed: ${result.reason}`);
        el("output").textContent =
          `Failed: ${result.reason}\nExpanded: ${result.explored.toLocaleString()} states\nTime: ${(t1-t0).toFixed(0)} ms`;
        return;
      }

      showSuccess(`Solved! Moves: ${result.moves.length}. Expanded: ${result.explored.toLocaleString()} states. Time: ${(t1-t0).toFixed(0)} ms`);
      el("status").textContent = "Done.";

      const showStates = el("showStates").checked;
      const shortMoves = el("shortMoves").checked;

      let text = "";
      text += `Initial state (top→bottom):\n${formatState(bottles)}\n`;
      let cur = bottles;

      result.moves.forEach((m, idx) => {
        const line = shortMoves
          ? `${idx+1}. ${m.from+1} → ${m.to+1}`
          : `${idx+1}. ${m.from+1} → ${m.to+1}  (poured ${m.amt} × ${m.color})`;
        text += line + "\n";
        cur = applyMoveForPrint(cur, m);
        if (showStates) text += formatState(cur) + "\n";
      });

      el("output").textContent = text;
    } catch (e) {
      showError(String(e?.message || e));
    }
  });
</script>
</body>
</html>
