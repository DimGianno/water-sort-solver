<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Water Sort Solver</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; font-size: 12px; color: #333; margin-bottom: 4px; }
    input[type="number"] { width: 140px; padding: 6px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #bbb; background: #fafafa; cursor: pointer; }
    button:hover { background: #f2f2f2; }
    .colors { display: flex; gap: 10px; flex-wrap: wrap; }
    .colors label { display:flex; gap:8px; align-items:center; font-size: 13px; user-select:none; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.2); display:inline-block; }
    .bottles { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 12px; margin-top: 12px; }
    .bottle { border: 1px solid #ddd; border-radius: 12px; padding: 10px; }
    .bottle h3 { margin: 0 0 8px; font-size: 14px; display:flex; justify-content:space-between; }
    .layers { display: grid; grid-template-columns: 1fr; gap: 6px; }
    select { padding: 6px; border-radius: 8px; border: 1px solid #ccc; }
    .hint { font-size: 12px; color: #555; margin-top: 8px; }
    .output { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; background: #0b1020; color: #e6e6e6; padding: 12px; border-radius: 12px; overflow:auto; max-height: 55vh; }
    .warn { color: #b00020; font-size: 13px; margin-top: 8px; }
    .ok { color: #0a7a22; font-size: 13px; margin-top: 8px; }
    .small { font-size: 12px; color:#444; }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <h1>Water Sort Solver (manual input → step-by-step solution)</h1>

  <div class="row">
    <div class="card">
      <div class="row">
        <div>
          <label>Number of bottles (max 14)</label>
          <input id="numBottles" type="number" min="3" max="14" value="11">
        </div>
      </div>
      <div class="hint">
        Capacity is always <b>4</b>. Last <b>2 bottles</b> are forced empty (helpers). All other bottles must be full.
      </div>
      <div class="inline" style="margin-top:10px;">
        <button id="buildBtn">Build bottles UI</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div id="buildMsg" class="small"></div>
    </div>

    <div class="card" style="flex:1; min-width: 320px;">
      <label>Select colors in this level (each must appear exactly 4 times)</label>
      <div id="colorChecklist" class="colors"></div>
      <div class="hint">
        Tip: Select only colors that exist in the level. Dropdowns will show how many layers are left.
      </div>
    </div>
  </div>

  <div id="bottleArea" class="bottles"></div>

  <div class="row" style="margin-top: 12px;">
    <div class="card" style="flex:1;">
      <div class="inline">
        <button id="solveBtn">Solve</button>
        <label class="inline" style="gap:6px; margin:0;">
          <input id="showStates" type="checkbox" checked>
          Show state after each move
        </label>
        <label class="inline" style="gap:6px; margin:0;">
          <input id="shortMoves" type="checkbox">
          Only moves (no poured amount)
        </label>
      </div>
      <div id="status" class="hint"></div>
      <div id="error" class="warn"></div>
      <div id="success" class="ok"></div>
    </div>
  </div>

  <div class="row" style="margin-top: 12px;">
    <div class="card" style="flex:1;">
      <label>Solution</label>
      <div id="output" class="output">Build bottles UI, enter colors, then press Solve.</div>
    </div>
  </div>

<script>
  // Fixed capacity
  const CAP = 4;

  // Palette (Black/White removed; Dark Green added)
  const COLOR_PALETTE = {
    "Red": "#e53935",
    "Pink": "#ec407a",
    "Orange": "#fb8c00",
    "Yellow": "#fdd835",
    "Green": "#43a047",
    "Dark Green": "#1b5e20",
    "Light Green": "#9ccc65",
    "Blue": "#1e88e5",
    "Light Blue": "#81d4fa",
    "Purple": "#8e24aa",
    "Gray": "#9e9e9e",
    "Brown": "#6d4c41",
  };
  const DEFAULT_COLORS = Object.keys(COLOR_PALETTE);

  const el = (id) => document.getElementById(id);

  function buildChecklist() {
    const box = el("colorChecklist");
    box.innerHTML = "";
    DEFAULT_COLORS.forEach((c) => {
      const lab = document.createElement("label");

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = c;
      cb.addEventListener("change", () => updateAllDropdownOptions());

      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = COLOR_PALETTE[c] || "#ccc";

      const name = document.createElement("span");
      name.textContent = c;

      lab.appendChild(cb);
      lab.appendChild(sw);
      lab.appendChild(name);
      box.appendChild(lab);
    });
  }

  function selectedColors() {
    return Array.from(el("colorChecklist").querySelectorAll("input[type=checkbox]:checked"))
      .map(x => x.value);
  }

  function showError(msg) {
    el("error").textContent = msg;
    el("success").textContent = "";
    el("status").textContent = "";
  }

  function showSuccess(msg) {
    el("success").textContent = msg;
    el("error").textContent = "";
  }

  function resetAll() {
    // Reset inputs
    el("numBottles").value = 11;
    el("showStates").checked = true;
    el("shortMoves").checked = false;

    // Uncheck all colors
    el("colorChecklist").querySelectorAll("input[type=checkbox]").forEach(cb => cb.checked = false);

    // Clear UI + messages
    el("bottleArea").innerHTML = "";
    el("buildMsg").textContent = "";
    el("status").textContent = "";
    el("error").textContent = "";
    el("success").textContent = "";
    el("output").textContent = "Build bottles UI, enter colors, then press Solve.";
  }

  function buildBottlesUI() {
    const n = parseInt(el("numBottles").value, 10);
    const colors = selectedColors();

    el("error").textContent = "";
    el("success").textContent = "";

    if (!Number.isFinite(n) || n < 3) return showError("Number of bottles must be >= 3.");
    if (n > 14) return showError("Max bottles is 14.");
    if (colors.length === 0) return showError("Select at least 1 color.");

    const area = el("bottleArea");
    area.innerHTML = "";

    for (let i = 0; i < n; i++) {
      const isHelperEmpty = (i >= n - 2);

      const b = document.createElement("div");
      b.className = "bottle";
      b.dataset.index = String(i);

      const title = document.createElement("h3");
      title.innerHTML = `<span>Bottle ${i+1}</span><span class="small">${isHelperEmpty ? "EMPTY" : ""}</span>`;
      b.appendChild(title);

      const layers = document.createElement("div");
      layers.className = "layers";

      for (let row = 0; row < CAP; row++) {
        const sel = document.createElement("select");
        sel.dataset.layer = String(row); // 0 is top in UI

        if (isHelperEmpty) {
          sel.disabled = true;
          sel.innerHTML = `<option value="">(empty)</option>`;
        } else {
          sel.innerHTML = `<option value="">(choose color)</option>`;
          sel.addEventListener("change", () => {
            setSelectBackground(sel);
            updateAllDropdownOptions();
          });
        }

        layers.appendChild(sel);
      }

      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = isHelperEmpty
        ? "Helper bottle (forced empty)"
        : "Set colors TOP → BOTTOM (must fill all 4 layers). Dropdown shows remaining layers per color.";
      b.appendChild(layers);
      b.appendChild(hint);

      area.appendChild(b);
    }

    el("buildMsg").textContent = `Built ${n} bottles (capacity fixed to 4).`;
    el("status").textContent = "Fill the bottles; remaining counts update automatically.";
    el("output").textContent = "Ready.";

    updateAllDropdownOptions(true);
  }

  function getAllUserSelects() {
    return Array.from(el("bottleArea").querySelectorAll(".bottle select"))
      .filter(sel => !sel.disabled);
  }

  function computeUsedCounts() {
    const counts = new Map();
    DEFAULT_COLORS.forEach(c => counts.set(c, 0));
    for (const sel of getAllUserSelects()) {
      const v = sel.value;
      if (v) counts.set(v, (counts.get(v) || 0) + 1);
    }
    return counts;
  }

  function setSelectBackground(sel) {
    const v = sel.value;
    if (!v) {
      sel.style.backgroundColor = "";
      sel.style.color = "";
      return;
    }
    const bg = COLOR_PALETTE[v] || "";
    sel.style.backgroundColor = bg;
    // Improve text contrast a bit (simple heuristic)
    sel.style.color = (v === "Yellow" || v === "Light Blue" || v === "Light Green") ? "#111" : "#fff";
  }

  function updateAllDropdownOptions(initialPopulate = false) {
    const area = el("bottleArea");
    if (!area || area.children.length === 0) return;

    const colors = selectedColors();
    if (colors.length === 0) return;

    const used = computeUsedCounts();
    const selects = getAllUserSelects();

    for (const sel of selects) {
      const current = sel.value || "";

      // remainingNow = how many more layers can still be placed across the whole grid
      // excluding this select’s current value (so we don’t hide its selected color).
      const opts = [];
      opts.push({ value: "", label: "(choose color)" });

      for (const c of colors) {
        const usedTotal = used.get(c) || 0;
        const effectiveUsed = usedTotal - (current === c ? 1 : 0);
        const remainingNow = CAP - effectiveUsed; // includes this slot if currently selected

        // Hide if no remaining and not currently selected
        if (remainingNow <= 0 && current !== c) continue;

        // Requirement #3:
        // - For the currently selected color, show ONLY the color name (no "(x left)")
        // - For others, show "(x left)" where x is how many are still available right now
        const label = (current === c) ? `${c}` : `${c} (${Math.max(0, remainingNow)} left)`;

        opts.push({ value: c, label });
      }

      // Rebuild options
      sel.innerHTML = "";
      for (const o of opts) {
        const opt = document.createElement("option");
        opt.value = o.value;
        opt.textContent = o.label;

        // Requirement #2: option background matches the color it represents
        if (o.value && COLOR_PALETTE[o.value]) {
          opt.style.backgroundColor = COLOR_PALETTE[o.value];
          opt.style.color = (o.value === "Yellow" || o.value === "Light Blue" || o.value === "Light Green") ? "#111" : "#fff";
        }
        sel.appendChild(opt);
      }

      // Restore current selection if still present
      if (current) {
        const found = Array.from(sel.options).some(o => o.value === current);
        sel.value = found ? current : "";
      } else if (initialPopulate) {
        sel.value = "";
      }

      // Keep select background in sync
      setSelectBackground(sel);
    }

    // Progress display
    const n = parseInt(el("numBottles").value, 10);
    const totalSlots = (n - 2) * CAP;
    const filled = selects.filter(s => s.value).length;
    el("status").textContent = `Filled ${filled}/${totalSlots} layers.`;
  }

  // ---------- Solver (BFS) ----------
  function isSolved(state) {
    for (const b of state) {
      if (b.length === 0) continue;
      if (b.length !== CAP) return false;
      const c0 = b[0];
      for (let i = 1; i < b.length; i++) if (b[i] !== c0) return false;
    }
    return true;
  }

  function topRun(b) {
    if (b.length === 0) return null;
    const tc = b[b.length - 1];
    let run = 1;
    for (let i = b.length - 2; i >= 0; i--) {
      if (b[i] === tc) run++;
      else break;
    }
    return { color: tc, run };
  }

  function canPour(src, dst) {
    if (src.length === 0) return false;
    if (dst.length >= CAP) return false;
    if (dst.length === 0) return true;
    return dst[dst.length - 1] === src[src.length - 1];
  }

  function doPour(src, dst) {
    const tr = topRun(src);
    const space = CAP - dst.length;
    const amt = Math.min(tr.run, space);
    const newSrc = src.slice(0, src.length - amt);
    const newDst = dst.concat(Array(amt).fill(tr.color));
    return { newSrc, newDst, amt, color: tr.color };
  }

  function encodeState(state) {
    return state.map(b => b.join(",")).join("|");
  }

  function cloneState(state) {
    return state.map(b => b.slice());
  }

  function usefulMovePrune(src, dst) {
    if (dst.length === 0 && src.length === CAP) {
      const c0 = src[0];
      let allSame = true;
      for (let i = 1; i < src.length; i++) if (src[i] !== c0) { allSame = false; break; }
      if (allSame) return false;
    }
    return true;
  }

  function bfsSolve(startState, maxStates = 400000) {
    const startKey = encodeState(startState);
    const q = [startState];
    let qHead = 0;

    const parent = new Map();
    parent.set(startKey, null);

    let explored = 0;

    while (qHead < q.length) {
      const state = q[qHead++];
      explored++;

      if (explored % 5000 === 0) {
        el("status").textContent = `Searching... explored ${explored.toLocaleString()} states`;
      }
      if (explored > maxStates) {
        return { ok:false, reason:`State limit reached (${maxStates.toLocaleString()}).`, explored };
      }

      if (isSolved(state)) {
        const solMoves = [];
        let key = encodeState(state);
        while (parent.get(key) !== null) {
          const rec = parent.get(key);
          solMoves.push(rec.move);
          key = rec.prevKey;
        }
        solMoves.reverse();
        return { ok:true, moves: solMoves, explored };
      }

      const n = state.length;
      const curKey = encodeState(state);
      const curRec = parent.get(curKey);
      const lastMove = curRec ? curRec.move : null;

      for (let i = 0; i < n; i++) {
        const src = state[i];
        if (src.length === 0) continue;

        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          if (lastMove && lastMove.from === j && lastMove.to === i) continue;

          const dst = state[j];
          if (!canPour(src, dst)) continue;
          if (!usefulMovePrune(src, dst)) continue;

          const next = cloneState(state);
          const res = doPour(next[i], next[j]);
          next[i] = res.newSrc;
          next[j] = res.newDst;

          const key = encodeState(next);
          if (!parent.has(key)) {
            parent.set(key, { prevKey: curKey, move: { from:i, to:j, amt:res.amt, color:res.color } });
            q.push(next);
          }
        }
      }
    }

    return { ok:false, reason:"No solution found (input may be invalid).", explored };
  }

  // ---------- Read & Validate ----------
  function readStateFromUI() {
    const n = parseInt(el("numBottles").value, 10);
    const bottles = [];

    for (let i = 0; i < n; i++) {
      const b = el("bottleArea").querySelector(`.bottle[data-index="${i}"]`);
      const selects = Array.from(b.querySelectorAll("select"));
      const topToBottom = selects.map(s => s.value).filter(v => v !== "");
      const bottomToTop = topToBottom.slice().reverse();
      bottles.push(bottomToTop);
    }
    return bottles;
  }

  function validateInput(bottles) {
    const n = bottles.length;
    const colors = selectedColors();
    if (colors.length === 0) return "Select colors first.";

    if (bottles[n-1].length !== 0 || bottles[n-2].length !== 0) {
      return "Last 2 bottles must be empty (helpers).";
    }

    for (let i = 0; i < n - 2; i++) {
      if (bottles[i].length !== CAP) return `Bottle ${i+1} must have exactly ${CAP} layers (full).`;
    }

    const counts = new Map();
    for (const c of colors) counts.set(c, 0);
    for (const b of bottles) for (const c of b) {
      if (!counts.has(c)) return `Color "${c}" is used but not selected in the checklist.`;
      counts.set(c, counts.get(c) + 1);
    }
    for (const c of colors) {
      const k = counts.get(c) || 0;
      if (k !== CAP) return `Color "${c}" appears ${k} times, but must appear exactly ${CAP} times.`;
    }

    return null;
  }

  function formatState(state) {
    let out = "";
    for (let i = 0; i < state.length; i++) {
      const b = state[i];
      const topToBottom = b.slice().reverse();
      const padded = topToBottom.concat(Array(CAP - topToBottom.length).fill("·"));
      out += `${String(i+1).padStart(2," ")}: ${padded.join("  ")}\n`;
    }
    return out;
  }

  function applyMove(state, move) {
    const next = cloneState(state);
    const res = doPour(next[move.from], next[move.to]);
    next[move.from] = res.newSrc;
    next[move.to] = res.newDst;
    return next;
  }

  // ---------- Wiring ----------
  buildChecklist();

  el("buildBtn").addEventListener("click", buildBottlesUI);
  el("resetBtn").addEventListener("click", resetAll);

  el("numBottles").addEventListener("change", () => {
    let v = parseInt(el("numBottles").value, 10);
    if (v > 14) v = 14;
    if (v < 3) v = 3;
    el("numBottles").value = v;
  });

  el("solveBtn").addEventListener("click", () => {
    el("error").textContent = "";
    el("success").textContent = "";
    try {
      const bottles = readStateFromUI();
      const err = validateInput(bottles);
      if (err) return showError(err);

      el("output").textContent = "Solving...\n";
      el("status").textContent = "Starting search...";
      const t0 = performance.now();
      const result = bfsSolve(bottles, 400000);
      const t1 = performance.now();

      if (!result.ok) {
        showError(`Failed: ${result.reason}`);
        el("output").textContent =
          `Failed: ${result.reason}\nExplored: ${result.explored.toLocaleString()} states\nTime: ${(t1-t0).toFixed(0)} ms`;
        return;
      }

      showSuccess(`Solved! Moves: ${result.moves.length}. Explored: ${result.explored.toLocaleString()} states. Time: ${(t1-t0).toFixed(0)} ms`);
      el("status").textContent = "Done.";

      const showStates = el("showStates").checked;
      const shortMoves = el("shortMoves").checked;

      let text = "";
      text += `Initial state (top→bottom):\n${formatState(bottles)}\n`;
      let cur = bottles;

      result.moves.forEach((m, idx) => {
        const line = shortMoves
          ? `${idx+1}. ${m.from+1} → ${m.to+1}`
          : `${idx+1}. ${m.from+1} → ${m.to+1}  (poured ${m.amt} × ${m.color})`;
        text += line + "\n";
        cur = applyMove(cur, m);
        if (showStates) text += formatState(cur) + "\n";
      });

      el("output").textContent = text;

    } catch (e) {
      showError(String(e?.message || e));
    }
  });
</script>
</body>
</html>
